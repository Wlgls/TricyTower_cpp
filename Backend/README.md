### TrickyTower 后端

### 前后端数据交流

前端会向后端发送的信号主要有

1. 用户创建时，发送shakehands握手帧，告知服务端有用户创建成功
2. 用户创建房间时，告知服务端该用户创建了房间
3. 用户加入房间时，告知服务端该用户加入了房间
4. 用户开始游戏时，告知服务端游戏开始，需开始进行心跳更新状态
5. 用户进行游戏时，客户端应定时向服务端发送该用户的状态。服务端会将其进行广播

后端向前端发送的信号主要有：
1. 当用户创建完成时，完成shakehands握手帧，应向该用户发送当前的房间信息。
2. 当用户创建房间，服务端应告知客户端创建成功信息，并将房间ID告知客户端以方便其进一步处理
3. 加入房间时，此时应更新用户状态，并更新房间信息。并向所有用户广播房间信息
4. 当用户开始游戏时，此时需更新用户状态和房间状态，向客户端发送哪些用户加入了游戏，可以更新这些玩家的展示了
5. 当用户进行游戏时，不断向玩家发送另外两个玩家的信息。


### 因此约定
2. 客户端向服务端发送创建房间的报文内容为，function为所约定关于房间的操作，room表示其名字：
```json
{
    "function": 1, // 表示创建房间
    "room":{ // 创建房间的信息
        "id": null,
        "name": "2345",
    }
}
```
3. 客户端向服务端告知加入房间时，需向服务端告知加入成功，并告知是加入的是哪个房间，使服务端更新内容。玩家信息以socketfd进行确认，减少传输数据。
```json
{
    "function": 2,
    "room":{
        "id":1,
        "name": "2345"
    }
}
```

4. 用户开始游戏时，应向服务端告知，哪个房间开始了游戏，
```json
{
    "function": 3,
    "room":{
        "id":1,
        "name":"2345",
    }
}
```

5. 当用户开始游戏时，应通过heartbeat不断向服务器告知自身的信息，方块的位置信息由前端约束，后端只需要转发
```json
    {
        "function":4,
        "room":{ // 房间的信息
            "id":1,
            "name":"2345"
        },
        "bodies":[ // 方块的位置信息
            // block1 message
            // block2 message
        ]
    }
```

#### 服务端向客户端约束
2. 当服务端收到客户端传来创建房间时，应向客户端告知创建成功，并告知客户端创建房间id，方便后续客户端操作
```json
{
    "function": 1,
    "type": 1,
    "roomId": 1,
}
```

3. 当服务端向客户端所有用户广播房间信息时，需要告知是哪个用户，告知不同房间的拥有者，以确定不同用户的展示不同（在创建者处展示其创建的房间）其数据操作应为：
```json
{
    "function":1,
    "type":2,
    "SocketId":6, // 创建的用户ID
    "data":[ // room列表
        { 
            "id": 1,
            "amount": 1, // 用户数量
            "name": "2345", // 房间名称
            "host": 6, // 约定该房间的所有者
            "player2": -1, // 约定该房间剩余两个人的id
            "player3": -1,
        }
        {
            "id": 2,
            "amount": 1, // 用户数量
            "name": "1234", // 房间名称
            "host": 5, // 约定该房间的所有者
            "player2": -1, // 约定该房间剩余两个人的id
            "player3": -1,
        }
    ]
}
```

4. 当收到客户端说开始游戏时，应向该房间的所有参与者告知开始游戏。
```json
{
    "function": 2,
}
```

5. 当在游戏进行时，需要向用户广播其余两个用户的信息，为了区分左右，额外设定`type`，其中`type=0`为左侧玩家，`type=1`为右侧玩家。
```json
{
    "function":3,
    "type":0,
    "data":[
        {"angle":0,"position":{"x":105.375,"y":5.5},"label":"1","id":6}
    ]
}
```


### 首先实现player和room的实心

对于room而言，并没有特别的操作，只需要保存相应的状态即可。

而对于player而言，其并不仅仅只是个player,还需要保存其状态与对应的socketfd以及自己的状态

### Channel和Epoll

采用Epoll进行多路I/O复用。

Channel类对socket的高级封装，主要保存监听的状态以及当事件来临时调用回调函数。

### Connection

服务端和客户端的一个连接，初始时应该是一个Tcp连接，但是经过shakehands应该升级为一个websocket连接

对当前连接需要进行监听。

根据上述应用

当一个读事件来临时，有以下几种情况： 
1. 用户创建账号时，需向该用户告知当前有什么room
2. 当某个用户加入房间/创建房间时，需向所有用户进行广播room情况
2. 当某个用户开始游戏时，
